/**
* @file bha.h
* Implementation of Black Hole algorithm.
*
* @author Qiuchen Qian <qiuchen.qian19@imperial.ac.uk>
*/

#pragma once
#include <sstream>
#include <valarray>

#include "drone.h"
#include "algs.h"


#ifndef BHA_H
#define BHA_H

/*! @class Bha
* @headerfile bha.h "bha.h"
* @brief Implementation of @a BlackHole class. The @a BlackHole class includes
* basic attributes like target, trail vectors, metric vectors, etc. and actions
* like attract, calculate fitness function etc. Note that total sensor node
* number should be larger than 8 (at least), otherwise, there's no need to
* execute BHA.
*
* @author Qiuchen Qian
* @version 6
* @date	2021
* @copyright MIT Public License
*/

class Bha
{
public:
	std::vector<Point> req_ps;					/* The vector of coordinates of SNs to be recharged */

	Bha() {};
	/* Construct Bha class with user-defined arguments.
	* @param n_case: Case ID to identify the input files of one case.
	* @param pref_eng: Priority weight of recharging energy, range [0, 100].
	* @param n_gen: The number of iterations in BHA.
	* @param ap: Probability to execute attract().
	*/
	Bha(int pref_eng, int pop_, int gen_, int ap, int n_search) :
		_wt_eng(pref_eng), _population(pop_), _generation(gen_),
		_attr_prob(ap), _search_num(n_search) {};
	~Bha() {};

	// Get UAV remain energy.
	float getDroneE() const { return _uav_energy; }

	// Get BH metric only.
	void getBhMet(float& metric) 
	{ 
		_updateAllBhRes();
		metric = _bh_metric; 
	}
	// Get BH solution only.
	void getBhSol(std::vector<int>& solution) 
	{
		_updateAllBhRes();
		solution = _bh_sol;
	}
	// Get Black Hole solution summary.
	void getAllBhRes(std::vector<int>& solution, float& metric, 
		float& discharged_e, float& recharged_e)
	{
		_updateAllBhRes();
		solution = _bh_sol;
		metric = _bh_metric;
		discharged_e = _bh_discharged_e;
		recharged_e = _bh_recharged_e;
	}
	// Get Black Hole discharged and recharged energy.
	void getBhDeRe(float& discharged_e, float& recharged_e)
	{
		_updateAllBhRes();
		discharged_e = _bh_discharged_e;
		recharged_e = _bh_recharged_e;
	}

	// Set Initial solution
	void setInitSol(const std::vector<int>& init_sol) { _bh_sol = init_sol; }
	// Set UAV initial energy.
	void setInitE(float init_e) { _uav_energy = init_e; }
	// Set UAV initial coordinate.
	void setInitPt(const std::unique_ptr<Point>& pt) { _init_coord.setPt(*pt); }
	// Set base station coordinate.
	void setEndPt(const std::unique_ptr<Point>& pt) { _end_coord.setPt(*pt); }
	// Set `Grid` class
	void setWindGrid(Grid* wg) { _wind_grid = wg; }
	// Set `Obstacle` class
	void setObstacle(Obstacle* obs) { _obs = obs; }

	void updateBhFromProc(float better_m, std::vector<int> better_sol) 
	{ 
		_tars_metric[_bh_idx] = better_m;
		_tars_idx[_bh_idx] = better_sol;
	}

	/* Find the event horizon radius r
	* @param v: The population metric vector
	*/
	float findUpQuart(std::vector<float> v);

	/* Find appropriate candidate pool. Search strategy: Check previous, current and next
	* index with two factors: distance and prize, then get a simplified metric to fill the
	* candidate pool.
	*
	* @param sn_list: A vector of all sensor nodes.
	* @param cur_vec: We need to know the context, thus take current solution in.
	* @param cur_idx: The current element in the current solution vector.
	* @return A vector of indexes, which includes selected candidate index (i.e. nodes).
	*/
	std::vector<int> findCandidates(std::vector<Sensor> sn_list, std::vector<int> cur_vec, int cur_idx);
	/* According to current target vector, re-initialize a new solution.
	*
	* @param sn_list: A vector of all sensor nodes.
	* @param req_ps: The vector of coordinates of sensor to be recharged.
	* @param idx_list: The solution to be re-initialized.
	*/
	void initOneNewSol(std::vector<Sensor> sn_list, std::vector<int>& cur_sol);
	/* Initialize multiple new solutions based on the initial solution generated by
	* initial solver (until population number).
	*
	* @param sn_list: A vector of all sensor nodes.
	* @param search_num: The number of candinates in selection pool.
	*/
	void initPopNewSol(std::vector<Sensor> sn_list);
	/* A method to locally search possible solutions.
	*
	* @param bh_num: The index of the black hole.
	* @param sn_list: A vector of all sensor nodes.
	* @param req_ps: The vector of coordinates of sensor to be recharged.
	* @param tar_vec: The target vector at specific population id.
	*/
	void attract(int bh_num, std::vector<Sensor> sn_list, std::vector<int>& tar_vec);
	/* Calculate the fitness metric of one solution.
	*
	* @param sn_list: A vector of all sensor nodes.
	* @param idx_list: A vector of target indexes to be calculated.
	*/
	void fitness(const std::vector<Sensor>& sn_list, 
		const std::vector<int>& idx_list, float sn_list_e,
		float& metric, float& discharged_e, float& recharged_e);
	/* Implement all processes of BHA. This method includes initialization of 
	* target and trail vectors, and calculation of their fitness metric values.  
	* Please note that unlike normal BHA, both target and trail vectors are
	* generated from all sensor nodes as possible solutions. After comparsion of 
	* the black hole bound, the winner star will survive for next generation,
	* which will keep the 'population' evolving towards to desired direction 
	* (converge to a trusted solution).
	* 
	* @param sn_list: A vector of all sensor nodes.
	* @param t: BHA execution time.
	*/
	void initialization(std::vector<Sensor> sn_list, float all_e, float& or_met, 
		float& or_dis, float& or_re);

	void singleGenEvolve(std::vector<Sensor> sn_list, float all_e);

	int checkBhMet() 
	{
		int cnt = 0;
		for (unsigned i = 0; i < _tars_metric.size(); i++) {
			if (_tars_metric[i] <= 36.0774) cnt++;
		}
		return cnt;
	}
	
	void getBhEstEngTimePrize(const std::vector<Sensor>& sn_list, const std::vector<int> bh_sol,
		std::vector<float>& path_eng, std::vector<float>& path_time, std::vector<int>& path_prize);

private:
	// BHA hyper-parameters.
	int _generation = 0;						/* The number of iterations in BHA. */
	int _population = 0;						/* Population number. */
	int _wt_eng = 0;							/* Priority weight of Charged energy, range [0, 100]. */
	int _attr_prob = 0;							/* Probability to execute attract(). */
	int _search_num = 0;						/* The number of searched candidates. */
	// BHA calculation needed variables.
	int _bh_idx = 0;
	float _bh_metric = 0;						/* Black Hole solution metric. */
	float _bh_discharged_e = 0;					/* Black Hole solution discharged energy. */
	float _bh_recharged_e = 0;					/* Black Hole solution recharged energy. */
	std::vector<int> _bh_sol;					/* The final best solution. */
	std::vector<std::vector<int>> _tars_idx;	/* Initial solution to evolve. */
	std::vector<float> _tars_metric;			/* Corresponding metric for target vector. */
	std::vector<float> _tars_dischrg;			/* Total UAV discharged energy of each population. */
	std::vector<float> _tars_rechrg;			/* Total UAV recharged energy of each population. */
	// UAV related hyper-parameters.
	float _uav_energy = 0; 						/* The UAV remain energy of executing BHA. */
	Point _init_coord = Point();				/* UAV initial coordinate. */
	Point _end_coord = Point();					/* UAV end coordinate. */
	// Wind grid and possible obstacle.
	Grid* _wind_grid = nullptr;					/* Include wind consideration. */
	Obstacle* _obs = new Obstacle();			/* Include static obstacle consideration. */

	void _updateAllBhRes()
	{
		_bh_sol = _tars_idx[_bh_idx];
		_bh_metric = _tars_metric[_bh_idx];
		_bh_discharged_e = _tars_dischrg[_bh_idx];
		_bh_recharged_e = _tars_rechrg[_bh_idx];
	}
};

#endif